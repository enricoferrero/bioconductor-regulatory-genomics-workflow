---
title: "Bioconductor Regulatory Genomics Workflow"
author: "Enrico Ferrero"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(results = "hide", message = FALSE, warning = FALSE, fig.width = 8, fig.height = 8)
```

# Introduction

TODO: pharma challenge, better targets, genetics, post-GWAS challenge

# Workflow

## Overview

In this workflow we will explore how regulatory genomic data can be used to connect the genetic and transcriptional layers by providing a framework for the functional annotation of SNPs from GWASs.

We will start with a common scenario: we run a RNA-seq experiment comparing patients with a disease and healthy individuals, and would like to discover key disease genes and potential therapeutic targets by integrating genetic information in our analysis.

## Install and load packages

The code below will install all required packages and dependencies from Bioconductor.

```{r}
source("https://bioconductor.org/biocLite.R")
# uncomment following line to install packages
#biocLite(c("DESeq2", "GenomicFeatures", "GenomicRanges", "ggplot2", "gwascat", recount", "pheatmap", "RcolorBrewer", "rtracklayer", "R.utils", "splitstackshape", VariantAnnotation"))
```

## Gene expression data and differential gene expression analysis

The RNA-seq data we will be using comes from blood of patients with systemic lupus erythematosus (SLE) and healthy controls, and was published in [Hung et al. 2015](https://www.ncbi.nlm.nih.gov/pubmed/26382853).

We are going to use `recount` to obtain gene-level counts:

```{r}
library(recount)
# uncomment following line to download dataset
#download_study("SRP062966")
load(file.path("SRP062966", "rse_gene.RData"))
rse <- scale_counts(rse_gene)
rse
```

For a more detailed description of the `recount` package refer to its [vignette](http://bioconductor.org/packages/release/bioc/vignettes/recount/inst/doc/recount-quickstart.html) and [workflow](https://f1000research.com/articles/6-1558):
Other Bioconductor packages that can be used to get data from gene expression experiments directly in R are [GEOquery]() and [ArrayExpress](). 

So, we have `r ncol(rse)` samples.
This is what the data looks like:

```{r}
assay(rse)[1:10, 1:10]
```

From the gene IDs, we note this is a GENCODE annotation, which will be usedful later on.
Let's look at the metadata to check how we can split them between cases and controls:

```{r}
colData(rse)
```

The most interesting part of the metadata is contained in the `characteristics` column, which is a `CharacterList` object:

```{r}
colData(rse)$characteristics
```

Let's create some new columns with this information that can be used for the differential expression analysis.
We will also make sure that they are encoded as factors and that the correct reference layer is used:

```{r}
# disease status
colData(rse)$disease_status <- sapply(colData(rse)$characteristics, "[", 1)
colData(rse)$disease_status <- sub("disease status: ", "", colData(rse)$disease_status)
colData(rse)$disease_status <- sub("systemic lupus erythematosus \\(SLE\\)", "SLE", colData(rse)$disease_status)
colData(rse)$disease_status <- factor(colData(rse)$disease_status, levels = c("healthy", "SLE"))
# tissue
colData(rse)$tissue <- sapply(colData(rse)$characteristics, "[", 2)
colData(rse)$tissue <- sub("tissue: ", "", colData(rse)$tissue)
colData(rse)$tissue <- factor(colData(rse)$tissue)
# anti-ro
colData(rse)$anti_ro <- sapply(colData(rse)$characteristics, "[", 3)
colData(rse)$anti_ro <- sub("anti-ro: ", "", colData(rse)$anti_ro)
colData(rse)$anti_ro <- factor(colData(rse)$anti_ro)
# ism
colData(rse)$ism <- sapply(colData(rse)$characteristics, "[", 4)
colData(rse)$ism <-sub("ism: ", "", colData(rse)$ism)
colData(rse)$ism <- factor(colData(rse)$ism)
```

Let's check it's what we expect:

```{r}
colData(rse)[c("disease_status", "tissue", "anti_ro", "ism")]
```

OK, this looks more readable.
Let's check how many samples we have in each group:

```{r}
table(colData(rse)$disease_status)
```

To speed up code execution we will limit the number of SLE samples.
For simplicity, we select the first 18 (healthy) and the last 18 (SLE) samples from the original `RangedSummarizedExperiment` object:

```{r}
rse <- rse[, c(1:18, 82:99)]
```

Now we are ready to perform a simple differential gene expression analysis with DESeq2:

```{r}
library(DESeq2)
dds <- DESeqDataSet(rse, ~ disease_status)
dds <- DESeq(dds)
dds
```

Note that we used an extremely simple model; in the real world you will probably need to account for co-variables, potential confounders and interactions between them.
Please refer to the DESeq2 [vignette](http://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) and this [workflow](https://www.bioconductor.org/help/workflows/rnaseqGene/) for more details on how to use DESeq2.
[edgeR]() and [limma]() are good alternatives to DESEq2 for performing differential expression analyses.

We can now look at the data in more detail.
We use the variance stabilising transformation (VST) [Anders and Huber 2010]() for visualisation purposes:

```{r}
vsd <- vst(dds, blind = FALSE)
```

First, let's look at distances between samples to see if we can recover a separation between SLE and healthy samples:

```{r}
sampleDists <- as.matrix(dist(t(assay(vsd))))
rownames(sampleDists) <- vsd$disease_status
sampleDists[c(1, 18, 19, 36), c(1, 18, 19, 36)]
```

We will use the [pheatmap]() and [RColorBrewer]() packages for drawing the heatmap:

```{r}
library(pheatmap)
library(RColorBrewer)
colors <- colorRampPalette(rev(brewer.pal(9, "Blues")))(255)
pheatmap(sampleDists, col = colors)
```

Similarly, we can perform a principal component analysis (PCA) on the most variable 500 genes:

```{r}
plotPCA(vsd, intgroup = "disease_status")
```

This looks better, we can see some separation of healthy and SLE samples along both PC1 and PC2, though some SLE samples appear very similar to the healthy ones.
Next, we select genes that are differentially expressed below a 0.05 adjusted p-value threshold:

```{r}
res <- results(dds, alpha = 0.05)
res
```

We can look at a summary of the results:

```{r}
summary(res)
```

We can also visualise the log fold changes using an MA plot [Dudoit et al. 2002]():

```{r}
plotMA(res, ylim = c(-5,5))
```

For convenience, we will save our differentially expressed genes (DEGs) in another object:

```{r}
degs <- subset(res, padj < 0.05)
degs <- as.data.frame(degs)
head(degs)
```

We also map the GENCODE gene IDs to gene symbols using the annotation in the original `RangedSummarizedExperiment` object, which is going to be convenient later on:

```{r}
rowData(rse)
degs <- merge(rowData(rse), degs, by.x = "gene_id", by.y = "row.names", all = FALSE)
degs
```

## Accessing GWAS data

We have more than 3500 genes of interest at this stage.
Since we know that therapeutic targets with genetic evidence are more likely to progress through the drug discovery pipeline [Nelson et al., 2015](), one way to prioritise them could be to check which of these can be genetically linked to SLE.
To get hold of relevant GWAS data, we will be using the [gwascat]() Bioconductor package, which provides an interface to the [GWAS catalog]()
An alternative is to use the [GRASP]() database with the [grasp2db]() package.

```{r}
library(gwascat)
# uncomment following line to download file and build the gwasloc object all in one step
#snps <- makeCurrentGwascat()
# uncomment following line to download file
#download.file("http://www.ebi.ac.uk/gwas/api/search/downloads/alternative", destfile = "gwas_catalog_v1.0.1-associations_e90_r2017-12-04.tsv")
snps <- read.delim("gwas_catalog_v1.0.1-associations_e90_r2017-12-04.tsv", check.names = FALSE, stringsAsFactors = FALSE)
snps <- gwascat:::gwdf2GRanges(snps, extractDate = "2017-12-04")
genome(snps) <- "GRCh38"
snps
```

SNPs is a `gwasloc` object which is simply a wrapper around a `GRanges` object, the standard way to express genomic ranges in Bioconductor.
We are interested in SNPs associated with SLE:

```{r}
snps <- subsetByTraits(snps, tr = "Systemic lupus erythematosus")
snps
```

We can visualise these as a Manhattan plot to look at the distribution of GWAS p-values over chromosomes on a negative log scale (note that p-values lower than 1e-25 are truncated):

```{r, fig.height = 8, fig.width = 12}
traitsManh(gwr = snps, sel = snps, traits = "Systemic lupus erythematosus")
```

## Annotation of coding and proximal SNPs to target genes 

In order to annotate these variants, We need a a `TxDb` object, a reference of where transcripts are located on the genome.
We can build this using the [GenomicFeatutres]() package and annotation from GENCODE (which is the gene annotation used in our RNA-seq experiment):

```{r}
library(GenomicFeatures)
#download.file("ftp://ftp.sanger.ac.uk/pub/gencode/Gencode_human/release_25/gencode.v25.annotation.gff3.gz", destfile = "gencode.v25.annotation.gff3.gz")
txdb <- makeTxDbFromGFF("gencode.v25.annotation.gff3.gz")
txdb <- keepStandardChromosomes(txdb)
txdb
```

We will also need to convert the `gwasloc` object into a standard `GRanges` object:

```{r}
snps <- GRanges(snps)
names(snps) <- snps$SNPS
```

Let's check if the `gwasloc` and `TxDb` object use the same notation for chromosomes:

```{r}
seqlevelsStyle(snps)
seqlevels(snps)
seqlevelsStyle(txdb)
seqlevels(txdb)
```

OK, they do.
Now we can annotate our SNPs to genes using the [VariantAnnotation]() package.
Note that we also want to keep some of the metadata from the GWAS catalog.

```{r}
library(VariantAnnotation)
snps_anno <- locateVariants(snps, txdb, AllVariants())
snps_anno <- unique(snps_anno)
snps_anno
```

You can consult this [vignette]() and this [workflow]() for a more in-depth overview of the package.
We can visualise where these SNPs are located with [ggplot2]():

```{r}
library(ggplot2)
loc <- data.frame(table(snps_anno$LOCATION))
ggplot(data = loc, aes(x = reorder(Var1, -Freq), y = Freq)) +
  geom_bar(stat="identity")
```

As expected [Maurano et al. 2012](), The great majority of SNPs is located within introns and in intergenic regions.
For the moment, we will focus on SNPs that are either coding or in promoter and UTR regions, as these can be assigned to target genes rather unambigously:

```{r}
snps_easy <- subset(snps_anno, LOCATION == "coding" | LOCATION == "promoter" | LOCATION == "threeUTR" | LOCATION == "fiveUTR")
snps_easy <- as.data.frame(snps_easy)
head(snps_easy)
```

Now we can check if any of the genes we found to be differentially expressed in SLE is also genetically associated with the disease:

```{r}
snps_easy_in_degs <- merge(degs, snps_easy, by.x = "row.names", by.y = "GENEID", all = FALSE)
snps_easy_in_degs
```

So, we have `r length(snps_easy_in_degs$gene_id)` genes showing differential expression in SLE that are also genetically associated with the disease.
While this is an interesting result, these hits are likely to be already well-known as potential SLE targets given their genetic association.

## Use of regulatory genomic data to map intronic and intergenic SNPs to target genes

What about all the SNPs in introns and intergenic regions?
Some of those might be regulatory SNPs affecting the expression level of their target gene through a distal enhancer.

A well-established way to gain insights into target genes of regulatory SNPs is to use expression quantitative trait loci (eQTL) data, where correlations between genetic variants and expression of genes are computed across different tissues or cell types [REF]().
However, in this workflow we will not be discussing this approach and will focus on utilising regulatory genomic data such as correlations and chromatin interactions between enhancers and promoters.

First, let's create a dataset of candidate regulatory SNPs that are either intronic or intergenic and remove the annotation obtained with `VariantAnnotation`:

```{r}
snps_hard <- subset(snps_anno, LOCATION == "intron" | LOCATION == "intergenic", select = "LOCATION")
snps_hard
```

# FANTOM5 data

The FANTOM5 consortium [REF]() profiled gene expression across a large panel of tissues and cell types using cap analysis of gene expression (CAGE).
This technology allows mapping of transcription start sites (TSSs) and enhancer RNAs (eRNAs) genome-wide.
Correlations between these promoter and enhancer elements across a large panel of tissues and cell types can then be used to identify significant promoter - enhancer pairs, that we can use to map distal regulatory SNPs to target genes.

We can have a look at the enhancer - promoter correlation data in this way:

```{r}
# uncomment the following line to download the file
#download.file("http://enhancer.binf.ku.dk/presets/enhancer_tss_associations.bed", destfile = "enhancer_tss_associations.bed")
fantom <- read.delim("enhancer_tss_associations.bed", skip = 1, stringsAsFactors = FALSE)
head(fantom)
```

Everything we need is in the fourth column, `name`: genomic location of the enhancer, gene identifiers, correlation and significance.
We will use the splitstackshape package [REF]() to parse it:

```{r}
library(splitstackshape)
fantom <- as.data.frame(cSplit(fantom, splitCols = "name", sep = ";", direction = "wide"))
head(fantom)
```

Now we need to parse the `name_1` column which contains the genomic location of the enhancers:

```{r}
locs <- strsplit(as.character(fantom$name_1), "[:-]")
fantom$chr <- sapply(locs, "[", 1)
fantom$start <- as.numeric(sapply(locs, "[", 2))
fantom$end <- as.numeric(sapply(locs, "[", 3))
fantom$symbol <- fantom$name_3
fantom$corr <- sub("R:", "", fantom$name_4)
fantom$fdr <- sub("FDR:", "", fantom$name_5)
head(fantom)
```

We can select only those enhancer - promoter pairs with a decent level of correlation and significance and tidy the data at the same time:

```{r}
fantom <- unique(subset(fantom, subset = corr >= 0.25 & fdr < 1e-5, select = c("chr", "start", "end", "symbol")))
head(fantom)
```

Now we would like to check whether any of our candidate regulatory SNPs are falling in any of these enhancers.
To do this, we have to convert the `data.frame` into a `GRanges` object:

```{r}
fantom <- makeGRangesFromDataFrame(fantom, keep.extra.columns = TRUE)
fantom
```

From the publication [REF]() we know these are mapped to genome reference GRCh37, so we will uplift them to GRCh38 using rtracklayer [REF]() and a mapping ("chain") file.
The R.utils package is required to extract the gzipped file: 

```{r}
library(rtracklayer)
library(R.utils)
# uncomment the following line to download file
#download.file("http://hgdownload.cse.ucsc.edu/goldenPath/hg19/liftOver/hg19ToHg38.over.chain.gz", destfile = "hg19ToHg38.over.chain.gz")
# uncomment the following line to extract gzipped file
#gunzip("hg19ToHg38.over.chain.gz")
ch <- import.chain("hg19ToHg38.over.chain")
fantom <- unlist(liftOver(fantom, ch))
fantom
```

We will use the GenomicRanges package [REF]() to compute the overlap between SNPs and enhancers:

```{r}
library(GenomicRanges)
hits <- findOverlaps(snps_hard, fantom)
snps_hard_in_fantom = snps_hard[queryHits(hits)]
fantom_with_snps_hard = fantom[subjectHits(hits)]
mcols(snps_hard_in_fantom) <- cbind(mcols(snps_hard_in_fantom), mcols(fantom_with_snps_hard))
snps_hard_in_fantom <- as.data.frame(snps_hard_in_fantom)
snps_hard_in_fantom
```

We note that some of the SNPs are assigned to more than one gene.
This is because enhancers are promiscuous and can regulate multiple genes.

We can now check if any of these genes is differentially expressed in our RNA-seq data:

```{r}
snps_hard_in_fantom_in_degs <- merge(snps_hard_in_fantom, degs, by = "symbol", all = FALSE)
snps_hard_in_fantom_in_degs
```

We have identified `r length(snps_hard_in_fantom_in_degs$gene_id)` genes whose putative enhancers contain SLE GWAS SNPs.
Note that these were not previously identified as candidate genes of interest:

```{r}
intersect(snps_easy_in_degs$symbol, snps_hard_in_fantom_in_degs$symbol)
```

# Promoter Capture Hi-C data

More recently, chromatin interaction data was generated across 17 human primary blood cell types [REF]().
More than 30,000 promoter baits were used to capture promoter-interacting regions genome-wide.
These regions were then mapped to enhancer based on the Ensembl Regulatory Build [REF]() and can be accessed in the supplementary data of the paper:

```{r}
# uncomment the following line to download file
#download.file("http://www.cell.com/cms/attachment/2086554122/2074217047/mmc4.zip", destfile = "mmc4.zip")
# uncomment the following lines to extract zipped files
#unzip("mmc4.zip")
#unzip("DATA_S1.zip")
pchic <- read.delim("ActivePromoterEnhancerLinks.tsv", stringsAsFactors = FALSE)
head(pchic)
```

In this case, we will have to map the promoter baits to genes first.
We can do this by converting the baits to a `GRanges` object and then using the `TxDb` object we previously built to extract positions of transcription start sites (TSSs):

```{r}
baits <- GRanges(seqnames = pchic$baitChr, ranges = IRanges(start = pchic$baitSt, end = pchic$baitEnd))
tsss <- promoters(txdb, upstream = 0, downstream = 1, columns = "gene_id")
hits <- nearest(baits, tsss)
baits$gene_id <- unlist(tsss[hits]$gene_id)
baits
```

Now we can create a `GRanges` object of the enhancers in the promoter capture Hi-C data with the bait annotation attached:

```{r}
pchic <- GRanges(seqnames = pchic$oeChr, ranges = IRanges(start = pchic$oeSt, end = pchic$oeEnd), gene_id = baits$gene_id)
pchic <- unique(pchic)
pchic
```

Next, we basically repeat the steps we have taken when working with the FANTOM5 data to find SLE GWAS SNPs overalapping with these enhancers:

```{r}
hits <- findOverlaps(snps_hard, pchic)
snps_hard_in_pchic = snps_hard[queryHits(hits)]
pchic_with_snps_hard = pchic[subjectHits(hits)]
mcols(snps_hard_in_pchic) <- cbind(mcols(snps_hard_in_pchic), mcols(pchic_with_snps_hard))
snps_hard_in_pchic <- as.data.frame(snps_hard_in_pchic)
snps_hard_in_pchic
```

Finally, we check if any of these enhancer containing SLE variants are known to putatively regulate genes differentially expressed in SLE:

```{r}
snps_hard_in_pchic_in_degs <- merge(snps_hard_in_pchic, degs, by = "gene_id", all = FALSE)
snps_hard_in_pchic_in_degs
```

## Conclusions





